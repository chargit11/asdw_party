<!DOCTYPE html>
<html>
<head>
    <title>Back Attack - Castle Arena</title>
    <style>
        body { background: #1a1a1a; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; font-family: 'Arial Black', sans-serif; overflow: hidden; }
        #game-container { position: relative; border: 8px solid #333; box-shadow: 0 0 50px rgba(0,0,0,0.5); }
        #timer { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background: white; border: 4px solid #444; border-radius: 30px; padding: 5px 20px; font-size: 24px; color: #333; display: flex; align-items: center; z-index: 10; }
        canvas { display: block; background: #8d5524; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="timer">‚è± <span id="seconds">60</span></div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const timeDisplay = document.getElementById('seconds');

let timeLeft = 60;
const GRID = 80;
const OFFSET_X = 120;
const OFFSET_Y = 120;

// Track Layout based on the image (0 = grass/bush, 1 = track)
const map = [
    [1, 1, 1, 1, 1, 1, 1],
    [1, 0, 1, 0, 1, 0, 1],
    [1, 1, 1, 1, 1, 1, 1],
    [1, 0, 1, 0, 1, 0, 1],
    [1, 1, 1, 1, 1, 1, 1]
];

class Tank {
    constructor(x, y, color, isPlayer) {
        this.gridX = x;
        this.gridY = y;
        this.x = x * GRID + OFFSET_X;
        this.y = y * GRID + OFFSET_Y;
        this.color = color;
        this.isPlayer = isPlayer;
        this.dir = {x: 1, y: 0};
        this.nextDir = {x: 1, y: 0};
        this.bullets = [];
        this.alive = true;
    }

    draw() {
        if (!this.alive) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(Math.atan2(this.dir.y, this.dir.x));

        // Tank Body
        ctx.fillStyle = this.color;
        ctx.fillRect(-18, -15, 36, 30);
        ctx.strokeStyle = "black";
        ctx.lineWidth = 2;
        ctx.strokeRect(-18, -15, 36, 30);

        // Cannon
        ctx.fillStyle = "#333";
        ctx.fillRect(10, -4, 15, 8);

        // BACK TARGET (The Weak Spot)
        ctx.fillStyle = "red";
        ctx.beginPath();
        ctx.arc(-15, 0, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        ctx.restore();

        // Bullets
        ctx.fillStyle = "yellow";
        this.bullets.forEach((b, i) => {
            ctx.beginPath();
            ctx.arc(b.x, b.y, 5, 0, Math.PI * 2);
            ctx.fill();
            b.x += b.vx; b.y += b.vy;
            if(b.x < 0 || b.x > 800 || b.y < 0 || b.y > 600) this.bullets.splice(i, 1);
        });
    }

    move() {
        if (!this.alive) return;
        let targetX = this.gridX * GRID + OFFSET_X;
        let targetY = this.gridY * GRID + OFFSET_Y;

        // Move towards grid target
        if (this.x < targetX) this.x += 2;
        else if (this.x > targetX) this.x -= 2;
        if (this.y < targetY) this.y += 2;
        else if (this.y > targetY) this.y -= 2;

        // Reached intersection
        if (this.x === targetX && this.y === targetY) {
            let nextX = this.gridX + this.nextDir.x;
            let nextY = this.gridY + this.nextDir.y;

            if (map[nextY] && map[nextY][nextX] === 1) {
                // Prevent 180
                if (!(this.nextDir.x === -this.dir.x && this.nextDir.y === -this.dir.y)) {
                    this.dir = {...this.nextDir};
                }
            }
            
            // Wall collision check
            if (map[this.gridY + this.dir.y] && map[this.gridY + this.dir.y][this.gridX + this.dir.x] === 1) {
                this.gridX += this.dir.x;
                this.gridY += this.dir.y;
            }
        }
    }
}

function drawArena() {
    // 1. Cobblestone Ground
    ctx.fillStyle = "#a67c52";
    ctx.fillRect(0, 0, 800, 600);
    
    // 2. Outer Castle Walls & Towers
    ctx.fillStyle = "#5d8aa8"; // Blue towers
    const towerSize = 80;
    // Corners
    [ [0,0], [720,0], [0,520], [720,520] ].forEach(p => {
        ctx.fillRect(p[0], p[1], towerSize, towerSize);
        ctx.fillStyle = "#e52b50"; // Red roofs
        ctx.beginPath(); ctx.moveTo(p[0], p[1]); ctx.lineTo(p[0]+40, p[1]-20); ctx.lineTo(p[0]+80, p[1]); ctx.fill();
        ctx.fillStyle = "#5d8aa8";
    });

    // 3. Tracks (The White Rails)
    ctx.strokeStyle = "rgba(255,255,255,0.8)";
    ctx.lineWidth = 40;
    ctx.lineJoin = "round";
    
    for(let r=0; r<map.length; r++) {
        for(let c=0; c<map[r].length; c++) {
            if(map[r][c] === 1) {
                ctx.strokeRect(c*GRID + OFFSET_X - 20, r*GRID + OFFSET_Y - 20, 40, 40);
            } else {
                // Draw Bushes/Grass in the holes
                ctx.fillStyle = "#2d5a27";
                ctx.beginPath();
                ctx.arc(c*GRID + OFFSET_X, r*GRID + OFFSET_Y, 30, 0, Math.PI*2);
                ctx.fill();
            }
        }
    }
}

const player = new Tank(0, 0, "#00aaff", true);
const cpu = new Tank(6, 4, "#ff4444", false);

function update() {
    ctx.clearRect(0,0,800,600);
    drawArena();
    
    player.move();
    player.draw();

    cpu.move();
    // Simple AI turn logic
    if (cpu.x === cpu.gridX * GRID + OFFSET_X && cpu.y === cpu.gridY * GRID + OFFSET_Y) {
        if (Math.random() < 0.3) {
            const dirs = [{x:1,y:0}, {x:-1,y:0}, {x:0,y:1}, {x:0,y:-1}];
            cpu.nextDir = dirs[Math.floor(Math.random()*4)];
        }
    }
    cpu.draw();

    // Hit Detection
    player.bullets.forEach((b, i) => {
        let d = Math.hypot(b.x - cpu.x, b.y - cpu.y);
        if (d < 25) {
            // Logic to check if hit was from behind
            let angleToBullet = Math.atan2(b.y - cpu.y, b.x - cpu.x);
            let cpuFacing = Math.atan2(cpu.dir.y, cpu.dir.x);
            let diff = Math.abs(angleToBullet - (cpuFacing + Math.PI));
            if (diff < 0.8 || diff > 5.5) {
                cpu.alive = false;
                alert("BACK ATTACK! YOU WIN!");
                location.reload();
            }
            player.bullets.splice(i, 1);
        }
    });

    requestAnimationFrame(update);
}

// Timer
setInterval(() => { if(timeLeft > 0) timeLeft--; timeDisplay.innerText = timeLeft; }, 1000);

window.addEventListener('keydown', e => {
    if (e.key === "ArrowUp") player.nextDir = {x:0, y:-1};
    if (e.key === "ArrowDown") player.nextDir = {x:0, y:1};
    if (e.key === "ArrowLeft") player.nextDir = {x:-1, y:0};
    if (e.key === "ArrowRight") player.nextDir = {x:1, y:0};
    if (e.code === "Space") player.bullets.push({x: player.x, y: player.y, vx: player.dir.x*6, vy: player.dir.y*6});
});

update();
</script>
</body>
</html>
