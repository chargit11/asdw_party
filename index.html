<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASDW Party</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bubblegum+Sans&family=Chewy&family=Fredoka:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            background: linear-gradient(135deg, #ff9a9e 0%, #fad0c4 99%, #fad0c4 100%);
            font-family: 'Fredoka', sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-canvas {
            display: none;
            border: 8px solid #ff6b81;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            image-rendering: pixelated; /* Wii-style crispness */
        }

        .menu-container {
            width: 900px;
            height: 650px;
            background: rgba(255, 255, 255, 0.85);
            border-radius: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            padding: 30px;
            position: relative;
            overflow: hidden;
            border: 8px solid #ff6b81;
        }

        /* ... (keep your previous menu styles) ... */
    </style>
</head>
<body>
    <div class="menu-container">
        <!-- Your previous menu HTML here -->
        <h1 class="title">ASDW Party!</h1>
        <!-- avatars, games-grid, buttons, etc. -->
    </div>

    <canvas id="game-canvas" width="900" height="650"></canvas>

    <script>
        const menu = document.querySelector('.menu-container');
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');

        // Wii Party style colors & fonts
        const wiiBlue = '#00a1d6';
        const wiiPink = '#ff69b4';
        const wiiYellow = '#ffd700';
        const wiiGreen = '#32cd32';
        const wiiRed = '#ff4500';
        const wiiPurple = '#8a2be2';

        // Shared game variables
        let currentGame = null;
        const keys = {};
        window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        function startGame(gameType) {
            menu.style.display = 'none';
            canvas.style.display = 'block';
            currentGame = gameType;
            ctx.imageSmoothingEnabled = false; // Pixel perfect look
            if (gameType === 'zombie-tag') initZombieTag();
            if (gameType === 'back-attack') initBackAttack();
            if (gameType === 'friendly-face-off') initFriendlyFaceOff();
            gameLoop();
        }

        function backToMenu() {
            menu.style.display = 'flex';
            canvas.style.display = 'none';
            currentGame = null;
        }

        function quitGame() { location.reload(); }

        // =====================================
        // Zombie Tag - Aesthetic Wii Style
        // =====================================
        let zombies = [];
        let humans = [];

        function initZombieTag() {
            humans = [
                { x: 200, y: 200, color: wiiBlue, speed: 4, isZombie: false, name: 'P1' },
                { x: 700, y: 200, color: wiiRed, speed: 4, isZombie: false, name: 'P2' },
                { x: 200, y: 500, color: wiiGreen, speed: 4, isZombie: false, name: 'P3' },
                { x: 700, y: 500, color: wiiYellow, speed: 4, isZombie: false, name: 'P4' }
            ];
            zombies = [
                { x: 450, y: 325, color: wiiPurple, speed: 3.2 }
            ];
        }

        function updateZombieTag() {
            // Player 1: WASD
            if (keys['a']) humans[0].x -= humans[0].speed;
            if (keys['d']) humans[0].x += humans[0].speed;
            if (keys['w']) humans[0].y -= humans[0].speed;
            if (keys['s']) humans[0].y += humans[0].speed;

            // Player 2: Arrow keys
            if (keys['arrowleft']) humans[1].x -= humans[1].speed;
            if (keys['arrowright']) humans[1].x += humans[1].speed;
            if (keys['arrowup']) humans[1].y -= humans[1].speed;
            if (keys['arrowdown']) humans[1].y += humans[1].speed;

            // AI for P3 & P4 (simple random movement)
            [2,3].forEach(i => {
                if (Math.random() < 0.05) humans[i].dx = (Math.random()-0.5)*2;
                if (Math.random() < 0.05) humans[i].dy = (Math.random()-0.5)*2;
                humans[i].x += (humans[i].dx || 0) * humans[i].speed;
                humans[i].y += (humans[i].dy || 0) * humans[i].speed;
            });

            // Zombies chase nearest human
            zombies.forEach(z => {
                let closest = humans.reduce((best, h) => {
                    if (h.isZombie) return best;
                    let d = distance(z, h);
                    return d < distance(z, best) ? h : best;
                }, {x:0,y:0});
                moveTowards(z, closest, z.speed);
            });

            // Collision: turn human into zombie
            humans.forEach(h => {
                if (h.isZombie) return;
                [...zombies, ...humans.filter(p => p.isZombie)].forEach(z => {
                    if (distance(h, z) < 25) {
                        h.isZombie = true;
                        zombies.push(h);
                    }
                });
            });

            // Boundary
            [...humans, ...zombies].forEach(p => {
                p.x = Math.max(30, Math.min(870, p.x));
                p.y = Math.max(30, Math.min(620, p.y));
            });

            // Win condition
            const remainingHumans = humans.filter(h => !h.isZombie);
            if (remainingHumans.length <= 1) {
                alert(remainingHumans.length === 1 ? `${remainingHumans[0].name} wins!` : "Everyone's a zombie!");
                backToMenu();
            }
        }

        function drawZombieTag() {
            // Wii-style graveyard background
            ctx.fillStyle = '#1e1e2f';
            ctx.fillRect(0, 0, 900, 650);

            // Moon & clouds
            ctx.fillStyle = '#f0f8ff';
            ctx.beginPath();
            ctx.arc(750, 100, 80, 0, Math.PI*2);
            ctx.fill();

            // Simple grass
            ctx.fillStyle = '#2e8b57';
            ctx.fillRect(0, 550, 900, 100);

            // Draw players
            [...humans, ...zombies].forEach(p => {
                ctx.fillStyle = p.isZombie ? wiiPurple : p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 20, 0, Math.PI*2);
                ctx.fill();

                // Eyes
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(p.x-8, p.y-5, 6, 0, Math.PI*2);
                ctx.arc(p.x+8, p.y-5, 6, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(p.x-8, p.y-5, 3, 0, Math.PI*2);
                ctx.arc(p.x+8, p.y-5, 3, 0, Math.PI*2);
                ctx.fill();

                // Name
                ctx.fillStyle = 'white';
                ctx.font = 'bold 18px Fredoka';
                ctx.textAlign = 'center';
                ctx.fillText(p.name || '', p.x, p.y + 40);
            });
        }

        // =====================================
        // Back Attack - Railroad Tracks Version
        // =====================================
        let vehicles = [];
        let shots = [];
        let trackSegments = [];

        function initBackAttack() {
            vehicles = [
                { x: 300, y: 200, angle: 0, color: wiiBlue, alive: true, name: 'P1' },
                { x: 600, y: 200, angle: 0, color: wiiRed, alive: true, name: 'P2' },
                { x: 300, y: 450, angle: 0, color: wiiGreen, alive: true, name: 'P3' },
                { x: 600, y: 450, angle: 0, color: wiiYellow, alive: true, name: 'P4' }
            ];

            // Railroad tracks (Wii-style loops & turns)
            trackSegments = [
                { type: 'straight', x1: 150, y1: 100, x2: 750, y2: 100, dir: 'right' },
                { type: 'curve', cx: 750, cy: 100, r: 100, startAngle: Math.PI*1.5, endAngle: Math.PI*0.5, dir: 'down' },
                { type: 'straight', x1: 750, y1: 200, x2: 750, y2: 450, dir: 'down' },
                { type: 'curve', cx: 750, cy: 450, r: 100, startAngle: Math.PI*0.5, endAngle: Math.PI*1.5, dir: 'up' },
                { type: 'straight', x1: 750, y1: 550, x2: 150, y2: 550, dir: 'left' },
                { type: 'curve', cx: 150, cy: 550, r: 100, startAngle: Math.PI*0.5, endAngle: Math.PI*1.5, dir: 'up' },
                { type: 'straight', x1: 150, y1: 450, x2: 150, y2: 200, dir: 'up' },
                { type: 'curve', cx: 150, cy: 200, r: 100, startAngle: Math.PI*1.5, endAngle: Math.PI*0.5, dir: 'down' }
            ];

            // Start vehicles on tracks
            vehicles.forEach((v, i) => {
                v.onTrack = true;
                v.trackIndex = i % trackSegments.length;
                v.progress = 0.5;
            });
        }

        function updateBackAttack() {
            vehicles.forEach(v => {
                if (!v.alive) return;

                // Force movement along track
                if (v.onTrack) {
                    let seg = trackSegments[v.trackIndex];
                    v.progress += 0.005; // Constant speed

                    if (v.progress >= 1) {
                        v.progress = 0;
                        v.trackIndex = (v.trackIndex + 1) % trackSegments.length;
                        seg = trackSegments[v.trackIndex];
                    }

                    if (seg.type === 'straight') {
                        let dx = seg.x2 - seg.x1;
                        let dy = seg.y2 - seg.y1;
                        v.x = seg.x1 + dx * v.progress;
                        v.y = seg.y1 + dy * v.progress;
                        v.angle = Math.atan2(dy, dx);
                    } else { // curve
                        let angle = seg.startAngle + (seg.endAngle - seg.startAngle) * v.progress;
                        v.x = seg.cx + Math.cos(angle) * seg.r;
                        v.y = seg.cy + Math.sin(angle) * seg.r;
                        v.angle = angle + Math.PI/2; // tangent
                    }
                }

                // Turning: only when at curve or straight allows
                if (keys['a'] || keys['arrowleft']) v.angle -= 0.05;
                if (keys['d'] || keys['arrowright']) v.angle += 0.05;

                // Shooting (P1 Space, P2 Enter)
                if ((keys[' '] && v === vehicles[0]) || (keys['enter'] && v === vehicles[1])) {
                    shots.push({
                        x: v.x + Math.cos(v.angle) * 30,
                        y: v.y + Math.sin(v.angle) * 30,
                        angle: v.angle,
                        owner: v
                    });
                    keys[' '] = keys['enter'] = false;
                }
            });

            // Update shots
            shots = shots.filter(s => {
                s.x += Math.cos(s.angle) * 8;
                s.y += Math.sin(s.angle) * 8;
                return s.x > 0 && s.x < 900 && s.y > 0 && s.y < 650;
            });

            // Check hits (back of vehicle)
            vehicles.forEach(v => {
                if (!v.alive) return;
                shots.forEach(s => {
                    if (s.owner === v) return;
                    let backX = v.x - Math.cos(v.angle) * 25;
                    let backY = v.y - Math.sin(v.angle) * 25;
                    if (distance({x:backX, y:backY}, s) < 15) {
                        v.alive = false;
                        shots = shots.filter(shot => shot !== s);
                    }
                });
            });

            // Win
            const alive = vehicles.filter(v => v.alive);
            if (alive.length <= 1) {
                alert(alive.length === 1 ? `${alive[0].name} wins!` : "Tie!");
                backToMenu();
            }
        }

        function drawBackAttack() {
            // Wii Party arena style
            ctx.fillStyle = '#87ceeb';
            ctx.fillRect(0, 0, 900, 650);

            // Clouds
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(200, 80, 60, 0, Math.PI*2);
            ctx.arc(250, 60, 80, 0, Math.PI*2);
            ctx.arc(300, 80, 60, 0, Math.PI*2);
            ctx.fill();

            // Draw tracks
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 20;
            trackSegments.forEach(seg => {
                ctx.beginPath();
                if (seg.type === 'straight') {
                    ctx.moveTo(seg.x1, seg.y1);
                    ctx.lineTo(seg.x2, seg.y2);
                } else {
                    ctx.arc(seg.cx, seg.cy, seg.r, seg.startAngle, seg.endAngle);
                }
                ctx.stroke();
            });

            // Draw vehicles
            vehicles.forEach(v => {
                if (!v.alive) return;
                ctx.save();
                ctx.translate(v.x, v.y);
                ctx.rotate(v.angle);

                // Train-like body
                ctx.fillStyle = v.color;
                ctx.fillRect(-35, -15, 70, 30);
                ctx.fillStyle = 'black';
                ctx.fillRect(-35, -15, 20, 30); // Cabin

                // Cannon
                ctx.fillStyle = 'gray';
                ctx.fillRect(20, -8, 30, 16);

                // Back target
                ctx.fillStyle = 'red';
                ctx.fillRect(-40, -10, 15, 20);

                ctx.restore();

                ctx.fillStyle = 'white';
                ctx.font = 'bold 18px Fredoka';
                ctx.textAlign = 'center';
                ctx.fillText(v.name, v.x, v.y + 50);
            });

            // Shots
            shots.forEach(s => {
                ctx.fillStyle = 'yellow';
                ctx.beginPath();
                ctx.arc(s.x, s.y, 6, 0, Math.PI*2);
                ctx.fill();
            });
        }

        // =====================================
        // Friendly Face-Off - Puzzle Style
        // =====================================
        let puzzles = [];

        function initFriendlyFaceOff() {
            // Simple 3x3 grid puzzle (face parts)
            puzzles = Array(4).fill().map((_, i) => ({
                color: [wiiBlue, wiiRed, wiiGreen, wiiYellow][i],
                pieces: Array.from({length: 9}, (_, j) => ({
                    id: j,
                    x: Math.random()*800 + 50,
                    y: Math.random()*500 + 50,
                    rotation: 0,
                    placed: false
                })),
                name: ['P1','P2','P3','P4'][i]
            }));
        }

        let selected = null;

        canvas.addEventListener('mousedown', e => {
            if (currentGame !== 'friendly-face-off') return;
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            puzzles[0].pieces.forEach(p => { // Player 1 mouse control
                if (!p.placed && Math.hypot(p.x - mx, p.y - my) < 40) {
                    selected = p;
                }
            });
        });

        canvas.addEventListener('mousemove', e => {
            if (!selected) return;
            const rect = canvas.getBoundingClientRect();
            selected.x = e.clientX - rect.left;
            selected.y = e.clientY - rect.top;
        });

        canvas.addEventListener('mouseup', () => {
            if (!selected) return;
            // Snap to grid if close
            const gridX = 150 + Math.round((selected.x - 150)/80)*80;
            const gridY = 150 + Math.round((selected.y - 150)/80)*80;
            if (Math.hypot(selected.x - gridX, selected.y - gridY) < 60) {
                selected.x = gridX;
                selected.y = gridY;
                selected.placed = true;
            }
            selected = null;
        });

        canvas.addEventListener('wheel', e => {
            if (selected) {
                selected.rotation += e.deltaY > 0 ? Math.PI/2 : -Math.PI/2;
                e.preventDefault();
            }
        });

        function updateFriendlyFaceOff() {
            // AI players slowly place pieces
            puzzles.slice(1).forEach(puz => {
                if (Math.random() < 0.005 && puz.pieces.some(p => !p.placed)) {
                    let unplaced = puz.pieces.filter(p => !p.placed);
                    let piece = unplaced[Math.floor(Math.random()*unplaced.length)];
                    piece.x = 150 + (piece.id % 3)*80;
                    piece.y = 150 + Math.floor(piece.id/3)*80;
                    piece.rotation = Math.random() < 0.5 ? 0 : Math.PI;
                    piece.placed = true;
                }
            });

            // Check win
            puzzles.forEach((puz, i) => {
                if (puz.pieces.every(p => p.placed)) {
                    alert(`${puz.name} completed their face!`);
                    if (i < 2) backToMenu();
                }
            });
        }

        function drawFriendlyFaceOff() {
            ctx.fillStyle = '#fffacd';
            ctx.fillRect(0, 0, 900, 650);

            // Cute background
            ctx.fillStyle = '#add8e6';
            ctx.fillRect(0, 0, 900, 300);
            ctx.fillStyle = '#90ee90';
            ctx.fillRect(0, 300, 900, 350);

            puzzles.forEach((puz, i) => {
                let offsetX = 100 + i * 220;
                let offsetY = 150;

                // Board
                ctx.strokeStyle = puz.color;
                ctx.lineWidth = 8;
                ctx.strokeRect(offsetX-10, offsetY-10, 240, 240);

                // Title
                ctx.fillStyle = puz.color;
                ctx.font = 'bold 24px Chewy';
                ctx.textAlign = 'center';
                ctx.fillText(`${puz.name}'s Face`, offsetX + 120, offsetY - 30);

                puz.pieces.forEach(piece => {
                    ctx.save();
                    ctx.translate(piece.x, piece.y);
                    ctx.rotate(piece.rotation);

                    // Face parts (simple shapes)
                    ctx.fillStyle = puz.color;
                    if (piece.id === 0) { // Hair
                        ctx.fillRect(-40, -60, 80, 60);
                    } else if (piece.id === 1) { // Eyes
                        ctx.fillRect(-30, -20, 20, 20);
                        ctx.fillRect(10, -20, 20, 20);
                    } else if (piece.id === 2) { // Nose
                        ctx.beginPath();
                        ctx.moveTo(0, -10);
                        ctx.lineTo(-10, 20);
                        ctx.lineTo(10, 20);
                        ctx.fill();
                    } else if (piece.id === 3) { // Mouth
                        ctx.fillRect(-25, 20, 50, 15);
                    } // ... etc.

                    ctx.restore();
                });
            });
        }

        // Helpers
        function distance(a, b) {
            return Math.hypot(a.x - b.x, a.y - b.y);
        }

        function moveTowards(from, to, speed) {
            let dx = to.x - from.x;
            let dy = to.y - from.y;
            let dist = Math.hypot(dx, dy);
            if (dist > 0) {
                from.x += (dx / dist) * speed;
                from.y += (dy / dist) * speed;
            }
        }

        // Game loop
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (currentGame === 'zombie-tag') {
                updateZombieTag();
                drawZombieTag();
            } else if (currentGame === 'back-attack') {
                updateBackAttack();
                drawBackAttack();
            } else if (currentGame === 'friendly-face-off') {
                updateFriendlyFaceOff();
                drawFriendlyFaceOff();
            }

            requestAnimationFrame(gameLoop);
        }
    </script>
</body>
</html>
