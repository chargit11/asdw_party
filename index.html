<!DOCTYPE html>
<html>
<head>
    <title>Back Attack Remake</title>
    <style>
        body { background: #333; color: white; text-align: center; font-family: sans-serif; }
        canvas { background: #222; border: 4px solid #555; display: block; margin: 20px auto; }
        .ui { font-size: 1.2rem; margin-bottom: 10px; }
    </style>
</head>
<body>
    <h1>BACK ATTACK</h1>
    <div class="ui" id="status">Use ARROW KEYS to drive! Aim for their back!</div>
    <canvas id="gameCanvas" width="600" height="400"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const status = document.getElementById('status');

        const GRID_SIZE = 50;
        const BULLET_SPEED = 7;

        class Vehicle {
            constructor(x, y, color, isPlayer) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.isPlayer = isPlayer;
                this.dir = { x: 1, y: 0 }; // Initial direction (Right)
                this.nextDir = { x: 1, y: 0 };
                this.speed = 2;
                this.alive = true;
                this.bullets = [];
            }

            draw() {
                if (!this.alive) return;
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Determine rotation based on direction
                let angle = Math.atan2(this.dir.y, this.dir.x);
                ctx.rotate(angle);

                // Draw Vehicle Body
                ctx.fillStyle = this.color;
                ctx.fillRect(-20, -15, 40, 30);
                
                // Draw Front (Cannon)
                ctx.fillStyle = "black";
                ctx.fillRect(10, -5, 15, 10);

                // Draw Back Target (The vulnerable spot!)
                ctx.fillStyle = "red";
                ctx.beginPath();
                ctx.arc(-18, 0, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = "white";
                ctx.stroke();

                ctx.restore();

                // Draw Bullets
                this.bullets.forEach((b, i) => {
                    ctx.fillStyle = "yellow";
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    b.x += b.vx;
                    b.y += b.vy;
                    // Remove bullets off screen
                    if(b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) this.bullets.splice(i, 1);
                });
            }

            update() {
                if (!this.alive) return;

                // Simple Grid Logic: Only change direction when aligned with grid
                if (this.x % GRID_SIZE === 0 && this.y % GRID_SIZE === 0) {
                    // Prevent 180-degree turns (Original Game Rule)
                    if (!(this.nextDir.x === -this.dir.x && this.nextDir.y === -this.dir.y)) {
                        this.dir = { ...this.nextDir };
                    }
                }

                this.x += this.dir.x * this.speed;
                this.y += this.dir.y * this.speed;

                // Boundary collision
                if (this.x < 25) this.x = 25;
                if (this.x > canvas.width - 25) this.x = canvas.width - 25;
                if (this.y < 25) this.y = 25;
                if (this.y > canvas.height - 25) this.y = canvas.height - 25;
            }

            shoot() {
                if (!this.alive || this.bullets.length > 2) return;
                this.bullets.push({
                    x: this.x + this.dir.x * 20,
                    y: this.y + this.dir.y * 20,
                    vx: this.dir.x * BULLET_SPEED,
                    vy: this.dir.y * BULLET_SPEED
                });
            }
        }

        const player = new Vehicle(100, 100, "royalblue", true);
        const cpu = new Vehicle(500, 300, "crimson", false);

        function checkHit(bullet, target) {
            // Check if bullet hits target area
            let dist = Math.hypot(bullet.x - target.x, bullet.y - target.y);
            if (dist < 20) {
                // Was it a BACK attack? 
                // Calculate angle from target to bullet
                let angleToBullet = Math.atan2(bullet.y - target.y, bullet.x - target.x);
                let targetFacing = Math.atan2(target.dir.y, target.dir.x);
                
                // If the bullet is hitting the opposite side of where the target is facing
                let diff = Math.abs(angleToBullet - (targetFacing + Math.PI));
                if (diff < 1 || diff > 5.2) { // Roughly 60 degrees behind
                    return "KILL";
                }
                return "BOUNCE";
            }
            return null;
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw Grid Lines
            ctx.strokeStyle = "#444";
            for(let i=0; i<canvas.width; i+=GRID_SIZE) { ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,canvas.height); ctx.stroke(); }
            for(let i=0; i<canvas.height; i+=GRID_SIZE) { ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(canvas.width,i); ctx.stroke(); }

            player.update();
            player.draw();
            
            cpu.update();
            // Basic AI: Randomly change direction at intersections
            if (cpu.x % GRID_SIZE === 0 && cpu.y % GRID_SIZE === 0 && Math.random() < 0.3) {
                const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
                cpu.nextDir = dirs[Math.floor(Math.random()*4)];
                if(Math.random() < 0.1) cpu.shoot();
            }
            cpu.draw();

            // Collision Detection
            player.bullets.forEach((b, i) => {
                let result = checkHit(b, cpu);
                if (result === "KILL") {
                    cpu.alive = false;
                    status.innerText = "YOU WIN! BACK ATTACK!";
                    player.bullets.splice(i, 1);
                } else if (result === "BOUNCE") {
                    player.bullets.splice(i, 1); // Shot blocked by front/side
                }
            });

            if(cpu.alive) requestAnimationFrame(gameLoop);
        }

        window.addEventListener('keydown', (e) => {
            if (e.key === "ArrowUp") player.nextDir = { x: 0, y: -1 };
            if (e.key === "ArrowDown") player.nextDir = { x: 0, y: 1 };
            if (e.key === "ArrowLeft") player.nextDir = { x: -1, y: 0 };
            if (e.key === "ArrowRight") player.nextDir = { x: 1, y: 0 };
            if (e.code === "Space") player.shoot();
        });

        gameLoop();
    </script>
</body>
</html>
